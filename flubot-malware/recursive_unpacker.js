#!/usr/bin/env node

// Usage: ./recursive_unpacker.js eval(function(p,a,c,k,e,d)...
// note: packed function should escape backslashes to ensure correct parsing
// ideas developed from inspecting http://dean.edwards.name/unpacker/
// use http://dean.edwards.name/packer/ to generate packed JavaScript and test the script

const atob = (b) => Buffer.from(b, "base64").toString("utf-8")
const btoa = (a) => Buffer.from(a).toString("base64")

const removeScript = (str) => {
    const startScript = "<script>"
    const endScript = "</script>"
    if(str.startsWith(startScript)) {
        const end = str.length - endScript.length
        return str.slice(startScript.length, end)
    }
    return str
}

const removeDocWrite = (str) => {
    if(str.indexOf("document.write") !== -1) {
        return str.slice(0, str.length - (str.length - str.indexOf("document.write")))
    }
}

const hasEval = (str) => str.startsWith("eval")

if (process.argv.length != 3) {
    console.error("Only accepts packed JavaScript as single CLI argument")
    process.exit(1)
}

const input = process.argv[2].trim()

const unpack = (packedStr) => {
    if(!hasEval(removeScript(packedStr))) {
        // base case: assume script without eval is no longer packed
        return packedStr;
    }
    // remove script tags and slice off "eval" from start of string
    const cleanedUpPackedStr = removeScript(packedStr).slice(4)
    // compute the packed function and parse as a string
    const unpackedStr = eval("String" + cleanedUpPackedStr)
    // compute the unpacked function without any document.write function
    const evaled = eval(removeDocWrite(unpackedStr))
    // recurse until the code is no longer packed
    return unpack(evaled)
}

console.log(unpack(input))
